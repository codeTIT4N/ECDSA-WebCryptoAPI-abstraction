import { assert } from "chai";
import { describe, it } from "mocha";
import {
  KeypairBase64,
  generateECDSAKeypairBase64,
  signMessage,
  verifySignedMessage,
  convertArrayBufferToBase64,
  convertBase64ToArrayBuffer,
} from "../src";
import * as crypto from "crypto";

describe("WebCryptoAPI abstraction tests", () => {
  let keypair: KeypairBase64;

  it("should generate a keypair", async () => {
    keypair = await generateECDSAKeypairBase64();
    assert.isString(keypair.privateKey);
    assert.isString(keypair.publicKey);
  });

  it("convertArrayBufferToBase64 should convert an ArrayBuffer to a base64 string", () => {
    const arrayBuffer = new Uint8Array([1, 2, 3, 4, 5]).buffer;
    const base64 = convertArrayBufferToBase64(arrayBuffer);
    assert.strictEqual(base64, "AQIDBAU=");
  });

  it("convertBase64ToArrayBuffer should convert a base64 string to an ArrayBuffer", () => {
    const base64 = "AQIDBAU=";
    const arrayBuffer = convertBase64ToArrayBuffer(base64);
    const expectedArrayBuffer = new Uint8Array([1, 2, 3, 4, 5]).buffer;
    assert.deepEqual(arrayBuffer, expectedArrayBuffer);
  });

  it("should sign a message", async () => {
    const message = "Test message to sign!";
    const signature = await signMessage(message, keypair.privateKey);
    assert.isString(signature);
  });

  it("should verify a signed message", async () => {
    const message = "Test message to sign!";
    const isVerified = await verifySignedMessage(
      keypair.publicKey,
      message,
      await signMessage(message, keypair.privateKey),
    );
    assert.strictEqual(isVerified, true, "verify failed");
  });

  it("should fail to verify a signed message if the message is changed", async () => {
    const message = "Test message to sign!";
    const isVerified = await verifySignedMessage(
      keypair.publicKey,
      message + "a",
      await signMessage(message, keypair.privateKey),
    );
    assert.strictEqual(isVerified, false, "verify failed");
  });

  it("should fail to verify a signed message if the signature is not signed by the correct private key", async () => {
    const message = "Test message to sign!";
    const newKeypair = await generateECDSAKeypairBase64();
    const isVerified = await verifySignedMessage(
      newKeypair.publicKey,
      message,
      await signMessage(message, keypair.privateKey),
    );
    assert.strictEqual(isVerified, false, "verify failed");
  });

  it("signature verification should also work with the crypto module", async () => {
    const message = "Test message to sign!";
    const signature = await signMessage(message, keypair.privateKey);
    // verifying the signature
    const isVerified = await crypto.subtle.verify(
      {
        name: "ECDSA",
        hash: { name: "SHA-256" },
      },
      await crypto.subtle.importKey(
        "spki",
        convertBase64ToArrayBuffer(keypair.publicKey),
        {
          name: "ECDSA",
          namedCurve: "P-256",
        },
        true,
        ["verify"],
      ),
      convertBase64ToArrayBuffer(signature),
      new TextEncoder().encode(message),
    );

    assert.strictEqual(isVerified, true, "verify failed");
  });

  it("the signature generated by the crypto module should also be verifiable by this module", async () => {
    const message = "Test message to sign!";
    const signature = await crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: { name: "SHA-256" },
      },
      await crypto.subtle.importKey(
        "pkcs8",
        convertBase64ToArrayBuffer(keypair.privateKey),
        {
          name: "ECDSA",
          namedCurve: "P-256",
        },
        true,
        ["sign"],
      ),
      new TextEncoder().encode(message),
    );
    const isVerified = await verifySignedMessage(
      keypair.publicKey,
      message,
      convertArrayBufferToBase64(signature),
    );
    assert.strictEqual(isVerified, true, "verify failed");
  });
});
