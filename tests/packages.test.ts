import { assert } from "chai";
import { describe, it } from "mocha";
import {
  KeypairBase64,
  generateECDSAKeypairBase64,
  signMessage,
  verifySignedMessage,
  convertArrayBufferToBase64,
  convertBase64ToArrayBuffer,
} from "../src";
import * as crypto from "crypto";

describe("Tests", () => {
  let keypair: KeypairBase64;

  it("should generate a keypair", async () => {
    keypair = await generateECDSAKeypairBase64();
    assert.isString(keypair.privateKey);
    assert.isString(keypair.publicKey);
  });

  it("convertArrayBufferToBase64 should convert an ArrayBuffer to a base64 string", () => {
    const arrayBuffer = new Uint8Array([1, 2, 3, 4, 5]).buffer;
    const base64 = convertArrayBufferToBase64(arrayBuffer);
    assert.strictEqual(base64, "AQIDBAU=");
  });

  it("convertBase64ToArrayBuffer should convert a base64 string to an ArrayBuffer", () => {
    const base64 = "AQIDBAU=";
    const arrayBuffer = convertBase64ToArrayBuffer(base64);
    const expectedArrayBuffer = new Uint8Array([1, 2, 3, 4, 5]).buffer;
    assert.deepEqual(arrayBuffer, expectedArrayBuffer);
  });

  //TODO
  /*
  it("the generated signature should be valid as if it was generated by the crypto library", async () => {
    const importedPrivateKey = await crypto.subtle.importKey(
      "pkcs8",
      convertBase64ToArrayBuffer(keypair.privateKey),
      {
        name: "ECDSA",
        namedCurve: "P-256",
      },
      true,
      ["sign"],
    );
    const signatureFromCrypto = await crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: { name: "SHA-256" },
      },
      importedPrivateKey,
      new TextEncoder().encode(message),
    );
    console.log(signatureFromCrypto);
    console.log(convertBase64ToArrayBuffer(signature));
    /*
    assert.deepEqual(
      signatureFromCrypto,
      convertBase64ToArrayBuffer(signature),
    );
    */
});

it("the signatu", async () => {
  /*
    // convert finalPrivateKey to CryptoKey
    const importedPrivateKey = await crypto.subtle.importKey(
      "pkcs8",
      convertBase64ToArrayBuffer(keypair.privateKey),
      {
        name: "ECDSA",
        namedCurve: "P-256",
      },
      true,
      ["sign"],
    );


    // convert finalPublicKey to CryptoKey
    const importedPublicKey = await crypto.subtle.importKey(
      "spki",
      convertBase64ToArrayBuffer(finalPublicKey),
      {
        name: "ECDSA",
        namedCurve: "P-256",
      },
      true,
      ["verify"],
    );

    // signing a message
    const message = "Test message to sign!";
    const signature = await crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: { name: "SHA-256" },
      },
      importedPrivateKey,
      new TextEncoder().encode(message),
    );

    // verifying the signature
    const isVerified = await crypto.subtle.verify(
      {
        name: "ECDSA",
        hash: { name: "SHA-256" },
      },
      importedPublicKey,
      signature,
      new TextEncoder().encode(message),
    );

    assert.strictEqual(isVerified, true, "verify failed");
    const message = "Hello World!";
    const verified = await verifySignedMessage(
      keypair.publicKey,
      message,
      await signMessage(message, keypair.privateKey),
    );
    assert.isTrue(verified);
    */
  /*
  it("should verify a signed message", () => {
    const keypair = generateECDSAKeypairBase64();
    const signature = signMessage("Hello World!", keypair.privateKey);
    const verified = verifySignedMessage(
      "Hello World!",
      signature,
      keypair.publicKey,
    );
    assert.isTrue(verified);
  });
  */
});
